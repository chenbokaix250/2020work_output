---
* export
设置或显示环境变量
>export [-fnp][变量名称]=[变量设置值]

在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅限于该次登陆操作。

参数

* -f 代表[变量名称]中为函数名称
* -n 删除指定的变量 变量实际上并未删除,只是不会输出到后指令的执行环境中
* -p 列出所有的shell赋予程序的环境变量

---
local一般用于局部变量声明,多在函数内部使用
1. shell脚本中定义的变量是global的,其作用域从被定义的地方开始,到shell结束或被显示删除的地方为止.
2. shell函数定义的变量默认是global的,其作用域从'函数被调用时执行变量定义的地方'开始,到shell结束或者被显删除处为止.函数定义的变量可以被显示定义成local的,其作用域局限于函数内.(但请注意,函数的参数是local的)
3. 如果同名,shell函数定义的local变量会屏蔽脚本定义的global变量


---
mkdir -p 参数是能直接创建一个不存在的目录下的子目录
eg:mkdir -p A/B
创建A文件夹下有B文件夹

---

find常见的用法

Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。
>find /dev -name "${1}"
`-find path -option [-print] [-exec -ok command] {}\;`
find命令的参数:

---
linux中shell变量$#,$@,$0,$1,$2的含义解释: 
变量说明: 
$$ 
Shell本身的PID（ProcessID） 
$! 
Shell最后运行的后台Process的PID 
$? 
最后运行的命令的结束代码（返回值） 
$- 
使用Set命令设定的Flag一览 
$* 
所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 
$@ 
所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 
$# 
添加到Shell的参数个数 
$0 
Shell本身的文件名 
$1～$n 
添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 
---
linux中的ln命令
当我们在不同的路径下用到相同的文件时，不需要在两个路径下都存放该文件以避免浪费空间，而可以用连接ln命令产生一个文件的连接。 ln命令是用来为文件创建连接的，连接又分为硬连接（hard link）和软连接（symbolic link），软连接又称为符号连接，默认为硬
-s 用来软连接
![In命令](https://file.tink.im/selif/otzhfv22.png)

---
shell中的for循环
三种 列表for循环/不带列表for循环/类c风格的for循环
1. 列表循环
```
for variable1 in {1..5}
do
    echo 'Hello,$variable1'
done
```
```
for i in {1..100..2}//跳跃的方式实现列表for循环
do
    xxx
done
```
```
for i in $(seq 1 2 100)//seq表示起始数为1，跳跃的步数为2，结束条件值为100
do
    xxx
done
//如果跳跃为1 可以不写出来  seq 1 100
```
2. 不带列表循环
```
for argument
do
    echo '$argument'
done
```
3. 类c风格的for循环
```
for((integer = 1; integer <= 5; integer++))
do
    echo "$integer"
done
```
---
###　mknod命令
mknod命令用于创建Linux中的字符设备文件和块设备文件
mknod(选项)(参数)
>选项:
-Z:设置安全的上下文
-m:设置权限模式
-help:显示帮助信息
--version:显示版本信息
>参数
* 文件名：要创建的设备文件名；
* 类型：指定要创建的设备文件的类型；
* 主设备号：指定设备文件的主设备号；
* 次设备号：指定设备文件的次设备号

>Linux的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存放在/dev目录 下，称为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。

>为了管理这些设备，系统为设备编了号，每 个设备号又分为主设备号和次设备号。主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。对于常用设备，Linux有约定俗成的编 号，如硬盘的主设备号是3。

>Linux为所有的设备文件都提供了统一的操作函数接口，方法是使用数据结构struct file_operations。这个数据结构中包括许多操作函数的指针，如open()、close()、read()和write()等，但由于外设 的种类较多，操作方式各不相同。Struct file_operations结构体中的成员为一系列的接口函数，如用于读/写的read/write函数和用于控制的ioctl等。

>打开一个文件就是调用这个文件file_operations中的open操作。不同类型的文件有不同的file_operations成员函数，如普通的磁盘数据文件， 接口函数完成磁盘数据块读写操作；而对于各种设备文件，则最终调用各自驱动程序中的I/O函数进行具体设备的操作。这样，应用程序根本不必考虑操作的是设 备还是普通文件，可一律当作文件处理，具有非常清晰统一的I/O接口。所以file_operations是文件层次的I/O接口。

---
* 指令 df 可以显示目前所有档案系统的最大可用空间及使用情形，请看下列这个例子

![image](https://file.tink.im/selif/yuqocbr5.png)

a：显示全部的档案系统和各分割区的磁盘使用情形
i：显示i -nodes的使用量
k：大小用k来表示 (默认值)
m: 大小用M表示
t：显示某一个档案系统的所有分割区磁盘使用量
x：显示不是某一个档案系统的所有分割区磁盘使用量
T：显示每个分割区所属的档案系统名称

*  指令du：查询档案或目录的磁盘使用空间
a：显示全部目录和其次目录下的每个档案所占的磁盘空间
b：大小用bytes来表示 (默认值为k bytes)
c：最后再加上总计 (默认值)
s：只显示各档案大小的总合 (summarize)
x：只计算同属同一个档案系统的档案
L：计算所有的档案大小

---

* sort 的用法及其参数
sort 将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。
sort -U 在输出行中去除重复行
sort -r 降序排列
sort -o 把结果输出到标准输出  需要用重定向才能将结果写入文件
sort -n 按照数值来排序
sort -t和-k 多列排序时用k t来设置间隔符


---
* pgrep命令
pgrep命令以名称为依据从运行进程队列中查找进程，并显示查找到的进程id。每一个进程ID以一个十进制数表示，通过一个分割字符串和下一个ID分开，默认的分割字符串是一个新行。对于每个属性选项，用户可以在命令行上指定一个以逗号分割的可能值的集合。

pgrep(选项)(参数)
-o：仅显示找到的最小（起始）进程号；
-n：仅显示找到的最大（结束）进程号；
-l：显示进程名称；
-P：指定父进程号；
-g：指定进程组；
-t：指定开启进程的终端；
-u：指定进程的有效用户ID。

---
* eval 重新运算求出参数的内容
eval命令将会首先扫描命令行进行所有的替换，然后再执行命令。